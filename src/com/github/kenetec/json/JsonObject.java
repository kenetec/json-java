package com.github.kenetec.json;

import java.util.*;
import java.util.stream.Collectors;

/**
 * <h1>JSON Object</h1>
 * Navigator for map generated by JSON.
 * Also doubles as a JSON Writer.
 */
public class JsonObject {
    /**
     * Contains a map of keys referring to objects, these
     * objects can be other JsonObjects, which are simply
     * the result of -> "key": {}
     */
    private HashMap<String, Object> map = new HashMap<String, Object>();
    private TokenType startTokenType;

    public JsonObject() {}

    /**
     * Creates a JsonObject
     * @param raw Map generated by JsonObjectGenerator
     */
    public JsonObject(HashMap<String, Object> raw) {
        generateMap(raw);
    }

    public JsonObject(HashMap<String, Object> raw, TokenType startTokenType) {
        generateMap(raw);
        this.startTokenType = startTokenType;
    }

    /**
     * Puts object in current JsonObject.
     * @param key
     * @param val
     */
    public void put(String key, Object val) {
        if (val instanceof HashMap) {
            HashMap<String, Object> valMap = (HashMap<String, Object>) val;

            this.map.put(key, new JsonObject(valMap));
        } else if (val instanceof ArrayList) {
            ArrayList<String> stringVals = new ArrayList<>();

            for (Object o : (ArrayList) val) {
                stringVals.add(o.toString());
            }

            this.map.put(key, stringVals);
        } else {
            this.map.put(key, val);
        }
    }

    /**
     * Puts a new key-value entry into the object.
     * @param keyPath
     * @param val
     * @throws EntryNotFoundException
     */
    public void putFromPath(String keyPath, Object val) throws EntryNotFoundException {
        HashMap<String, Object> targetMap = resolvePath(keyPath);

        String[] path = keyPath.split("\\.");
        String key = path[path.length-1];

        if (val instanceof HashMap) {
            HashMap<String, Object> valMap = (HashMap<String, Object>) val;

            targetMap.put(key, new JsonObject(valMap));
        } else if (val instanceof ArrayList) {
            ArrayList<String> stringVals = new ArrayList<>();

            for (Object o : (ArrayList) val) {
                stringVals.add(o.toString());
            }

            targetMap.put(key, stringVals);
        } else {
            targetMap.put(key, val);
        }
    }

    /**
     * Gets object of key in current JsonObject
     * @param key
     * @return Object
     */
    public Object get(String key) {
        return this.map.get(key);
    }

    /**
     * Gets object found from key path.
     * @param keyPath
     * @return
     * @throws EntryNotFoundException
     */
    public Object getFromPath(String keyPath) throws EntryNotFoundException {
        HashMap<String, Object> targetMap = resolvePath(keyPath);

        String[] path = keyPath.split("\\.");
        String key = path[path.length-1];

        return targetMap.get(key);
    }

    /**
     * Gets entry, parses it as double, and casts it as Number
     * @param keyPath
     * @return
     * @throws EntryNotFoundException
     */
    public Number getNumber(String keyPath) throws EntryNotFoundException {
        return (Number) Double.parseDouble((String) getFromPath(keyPath));
    }

    /**
     * Gets list and casts values to Number.
     * @param keyPath
     * @return
     * @throws EntryNotFoundException
     */
    public ArrayList<Number> getNumberList(String keyPath) throws EntryNotFoundException {
        ArrayList<String> val = (ArrayList<String>) getFromPath(keyPath);

        return (ArrayList<Number>) val.stream()
                .map(Double::parseDouble)
                .map((o) -> (Number) o)
                .collect(Collectors.toList());
    }

    /**
     * Gets list and casts values to Integer
     * @param keyPath
     * @return ArrayList
     * @throws EntryNotFoundException
     */
    public ArrayList<Integer> getIntList(String keyPath) throws EntryNotFoundException {
        ArrayList<String> val = (ArrayList<String>) getFromPath(keyPath);

        return (ArrayList<Integer>) val.stream()
                .map(Integer::parseInt)
                .collect(Collectors.toList());
    }

    /**
     * Gets list and casts values to Double
     * @param keyPath
     * @return ArrayList
     * @throws EntryNotFoundException
     */
    public ArrayList<Double> getDoubleList(String keyPath) throws EntryNotFoundException {
        ArrayList<String> val = (ArrayList<String>) getFromPath(keyPath);

        return (ArrayList<Double>) val.stream()
                .map(Double::parseDouble)
                .collect(Collectors.toList());
    }

    /**
     * Gets list and casts values to Long
     * @param keyPath
     * @return ArrayList
     * @throws EntryNotFoundException
     */
    public ArrayList<Long> getLongList(String keyPath) throws EntryNotFoundException {
        ArrayList<String> val = (ArrayList<String>) getFromPath(keyPath);

        return (ArrayList<Long>) val.stream()
                .map(Long::parseLong)
                .collect(Collectors.toList());
    }

    /**
     * Gets list and casts values to Float
     * @param keyPath
     * @return ArrayList
     * @throws EntryNotFoundException
     */
    public ArrayList<Float> getFloatList(String keyPath) throws EntryNotFoundException {
        ArrayList<String> val = (ArrayList<String>) getFromPath(keyPath);

        return (ArrayList<Float>) val.stream()
                .map(Float::parseFloat)
                .collect(Collectors.toList());
    }

    /**
     * Gets list and casts values to Byte
     * @param keyPath
     * @return ArrayList
     * @throws EntryNotFoundException
     */
    public ArrayList<Byte> getByteList(String keyPath) throws EntryNotFoundException {
        ArrayList<String> val = (ArrayList<String>) getFromPath(keyPath);

        return (ArrayList<Byte>) val.stream()
                .map(Byte::parseByte)
                .collect(Collectors.toList());
    }

    /**
     * Gets list and casts values to Short
     * @param keyPath
     * @return ArrayList
     * @throws EntryNotFoundException
     */
    public ArrayList<Short> getShortList(String keyPath) throws EntryNotFoundException {
        ArrayList<String> val = (ArrayList<String>) getFromPath(keyPath);

        return (ArrayList<Short>) val.stream()
                .map(Short::parseShort)
                .collect(Collectors.toList());
    }

    /**
     * Gets array key path and casts all values to T
     * @param keyPath
     * @return
     * @throws EntryNotFoundException
     */
    public <T> ArrayList<T> getArray(String keyPath) throws EntryNotFoundException {
        ArrayList<String> val = (ArrayList<String>) getFromPath(keyPath);
        ArrayList<T> ret = new ArrayList<>();

        for (String item : val) {
            ret.add((T) item);
        }

        return ret;
    }

    /**
     * Finds the HashMap that contains the last element in
     * given key path. (i.e. "quizzes.math.q1.name" -> finds q1 map
     * | "quizzes.math.q1." -> finds q1 map)
     * @param keyPath
     * @return
     * @throws EntryNotFoundException
     */
    private HashMap<String, Object> resolvePath(String keyPath) throws EntryNotFoundException {
        String[] path = keyPath.split("\\.");

        HashMap<String, Object> currentMap = this.map;

        for (int i = 0; i < path.length-1; i++) {
            String key = path[i];

            if (currentMap.containsKey(key)) {
                JsonObject nextObj;

                if ((nextObj = (JsonObject) currentMap.get(key)) != null) {
                    // go to next level
                    currentMap = nextObj.getMap();
                } else {
                    // endpoint
                    return currentMap;
                }
            } else {
                // throw error
                throw new EntryNotFoundException(keyPath);
            }
        }

        return currentMap;
    }

    /**
     * Dumps json string
     * @return
     */
    public String dump() {
        String dumpStr = "{";

        for (Map.Entry<String, Object> entry : this.map.entrySet()) {
            String key = entry.getKey();
            Object val = entry.getValue();

            // default "[data]"
            String data = "\"" + (val != null ? val.toString() : "null") + "\"";

            if (val instanceof JsonObject) {
                // {...}
                JsonObject jsonObject = (JsonObject) val;
                data = jsonObject.dump();
            } else if (val instanceof ArrayList) {
                // [...]
                ArrayList<String> arrayList = (ArrayList<String>) val;
                data = "[";

                for (String item : arrayList) {
                    data += "\"" + item + "\", ";
                }

                // delete last ", "
                data = data.substring(0, data.length()-2);
                data += "]";
            }

            // add entry
            dumpStr += "\"" + entry.getKey() + "\": " + data + ",";
        }

        // to remove last comma
        dumpStr = dumpStr.substring(0, dumpStr.length()-1);
        dumpStr += "}";

        return dumpStr;
    }


    /**
     * Dumps pretty json string
     * @return
     */
    public String prettyDump() {
        if (this.map.get("") != null) {
            return formatList((List<Object>) this.map.get(""), 0);
        }

        return formatSelf(0);
    }

    public String toString() {
        return prettyDump();
    }

    public HashMap<String, Object> getMap() {
        return map;
    }

    private void generateMap(HashMap <String, Object> raw) {
        for (Map.Entry<String, Object> entry : raw.entrySet()) {
            String key = entry.getKey();
            Object val = entry.getValue();

            if (val instanceof HashMap) {
                HashMap<String, Object> valMap = (HashMap<String, Object>) val;

                map.put(key, new JsonObject(valMap));
            } else {
                map.put(key, val);
            }
        }
    }

    private String formatSelf(int tabs) {
        String str = "{\n";

        for (Map.Entry<String, Object> entry : this.map.entrySet()) {
            String key = entry.getKey();
            Object val = entry.getValue();

            // tab padding for entry
            for (int i = 0; i < tabs + 1; i++) {
                str += "\t";
            }

            // add entry
            str += "\"" + key + "\": " + formatItem(val, tabs) + ",\n";
        }

        // to remove last comma
        str = str.substring(0, str.length()-2);

        str += "\n";

        // tab padding for '}'
        for (int i = 0; i < tabs; i++) {
            str += "\t";
        }

        str += "}";

        return str;
    }

    private String formatList(List<Object> list, int tabs) {
        String str = "";

        // "[...]"
        str = "[\n";

        for (Object item : list) {
            // tab padding for array entry
            for (int i = 0; i < tabs+1; i++) {
                str += "\t";
            }

            str +=  formatItem(item, tabs) + ",\n";
        }

        // remove ",\n"
        str = str.substring(0, str.length()-2);
        str += "\n";

        // tab padding for ']'
        for (int i = 0; i < tabs; i++) {
            str += "\t";
        }

        str += "]";

        return str;
    }

    private String formatItem(Object item, int tabs) {
        String formatted = "";

        if (item instanceof JsonObject) {
            formatted = ((JsonObject) item).formatSelf(tabs + 1);
        } else if (item instanceof String) {
            formatted = "\"" + (String) item + "\"";
        } else if (item instanceof List) {
            formatted = formatList((List<Object>) item, tabs + 1);
        } else {
            formatted = (item != null) ? item.toString() : "null";
        }

        return formatted;
    }
}
